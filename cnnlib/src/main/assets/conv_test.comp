layout (local_size_x = X_SIZE, local_size_y = Y_SIZE, local_size_z = Z_SIZE) in;

uniform int params[13];  // kennel_shape[3] input_shape[3] output_shape[3] strides[2] padding active_type
layout(binding = 0, rgba32f) readonly uniform image2D input_image;
layout(binding = 1, rgba32f) writeonly uniform image2D output_image;
layout(binding = 2, rgba32f) readonly uniform image2D kennel_image;
layout(std430, binding = 0) buffer BufferObject {
    int result_index[];
};
shared vec4 kennel[3][3][4];
void main() {
    // 分解参数
    int kennel_shape[3] = int[3](params[0], params[1] , params[2]);
    int input_shape[3] = int[3](params[3], params[4] , params[5]);
    int output_shape[3] = int[3](params[6], params[7] , params[8]);
    int strides[2] = int[2](params[9], params[10]);
    int padding = params[11];
    int active_type = params[12];
    int kennel_area = kennel_shape[0] * kennel_shape[1];

    ivec3 global_pos = ivec3(gl_GlobalInvocationID.xyz);
    ivec3 local_pos = ivec3(gl_LocalInvocationID.xyz);

     vec4 data = imageLoad(input_image, local_pos.xy);

     int start_z = global_pos.z * 4;

     int current_index = local_pos.x + local_pos.y * 3;
     if (local_pos.x < 3 && local_pos.y < 3){
        int k_pos_0_y = start_z;
        ivec2 k_pos_0 = ivec2(current_index, k_pos_0_y);
        kennel[local_pos.x][local_pos.y][0] = imageLoad(kennel_image, k_pos_0);
        int k_pos_1_y = start_z + 1;
        ivec2 k_pos_1 = ivec2(current_index, k_pos_1_y);
        kennel[local_pos.x][local_pos.y][1] = imageLoad(kennel_image, k_pos_1);
        int k_pos_2_y = start_z + 2;
        ivec2 k_pos_2 = ivec2(current_index, k_pos_2_y);
        kennel[local_pos.x][local_pos.y][2] = imageLoad(kennel_image, k_pos_2);
        int k_pos_3_y = start_z + 3;
        ivec2 k_pos_3 = ivec2(current_index, k_pos_3_y);
        kennel[local_pos.x][local_pos.y][3] = imageLoad(kennel_image, k_pos_3);
     }

     vec4 conv_reslut = vec4(0.0);

     int kennel_offset = kennel_area * 4 * current_index;
     for (int j=0; j < 9; j ++) {
         int start_index = 4 * j +  kennel_offset;
         int result_index_in_x = start_index;
         int result_index_in_y = start_index + 1;
         int result_index_k_x = start_index + 2;
         int result_index_k_y = start_index + 3;
         if (result_index_in_x > 0 && result_index_in_x < 32 && result_index_in_y >0 && result_index_in_y < 32) {
            vec4 in_data = imageLoad(input_image, ivec2(result_index_in_x, result_index_in_y));
            conv_reslut[0] += dot(in_data, kennel[result_index_k_x][result_index_k_y][0]);
            conv_reslut[1] += dot(in_data, kennel[result_index_k_x][result_index_k_y][1]);
            conv_reslut[2] += dot(in_data, kennel[result_index_k_x][result_index_k_y][2]);
            conv_reslut[3] += dot(in_data, kennel[result_index_k_x][result_index_k_y][3]);
         }
     }
     imageStore(output_image, global_pos.xy,  conv_reslut);
}
