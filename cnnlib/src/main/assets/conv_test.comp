layout (local_size_x = X_SIZE, local_size_y = Y_SIZE, local_size_z = 1) in;

uniform int params[13];  // kennel_shape[3] input_shape[3] output_shape[3] strides[2] padding active_type
layout(binding = 0, rgba32f) readonly uniform image2D input_image;
layout(binding = 1, rgba32f) writeonly uniform image2D output_image;
layout(binding = 2, rgba32f) readonly uniform image2D kennel_image;
layout(std430, binding = 0) buffer BufferObject {
    int result_index[4*3*3*32*32*Z*SIZE*Z_GROUP];      //Z_GROUP
};
shared vec4 kennel[3][3][4];
shared float result[32][32][3][3][4];
void main() {

    // 分解参数
    int kennel_shape[3] = int[3](params[0], params[1] , params[2]);
    int input_shape[3] = int[3](params[3], params[4] , params[5]);
    int output_shape[3] = int[3](params[6], params[7] , params[8]);
    int strides[2] = int[2](params[9], params[10]);
    int padding = params[11];
    int active_type = params[12];

    ivec3 global_pos = ivec3(gl_GlobalInvocationID.xyz);
    ivec3 local_pos = ivec3(gl_LocalInvocationID.xyz);

     vec4 data = imageLoad(input_image, local_pos.xy);
     int start_z = global_pos.z * 4;
     if (local_pos.x < 3 && local_pos.y < 3){
        int k_pos_0_y = start_z;
        ivec2 k_pos_0 = ivec2(local_pos.x + local_pos.y * 3 + k_pos_0_y * 9, k_pos_0_y);
        kennel[local_pos.x][local_pos.y][0] = imageLoad(kennel_image, k_pos_0);
        int k_pos_1_y = start_z + 1;
        ivec2 k_pos_1 = ivec2(local_pos.x + local_pos.y * 3 + k_pos_1_y * 9, k_pos_1_y);
        kennel[local_pos.x][local_pos.y][1] = imageLoad(kennel_image, k_pos_1);
        int k_pos_2_y = start_z + 2;
        ivec2 k_pos_2 = ivec2(local_pos.x + local_pos.y * 3 + k_pos_2_y * 9, k_pos_2_y);
        kennel[local_pos.x][local_pos.y][2] = imageLoad(kennel_image, k_pos_2);
        int k_pos_3_y = start_z + 3;
        ivec2 k_pos_3 = ivec2(local_pos.x + local_pos.y * 3 + k_pos_3_y * 9, k_pos_3_y);
        kennel[local_pos.x][local_pos.y][3] = imageLoad(kennel_image, k_pos_3);
     }
     barrier();
     for (int x =0; x< 3; x++) {
        for (int y =0; y < 3; y++) {
            result[global_pos.x][global_pos.y][x][y][0] = dot(data, kennel[x][y][0]);
            result[global_pos.x][global_pos.y][x][y][1] = dot(data, kennel[x][y][1]);
            result[global_pos.x][global_pos.y][x][y][2] = dot(data, kennel[x][y][2]);
            result[global_pos.x][global_pos.y][x][y][3] = dot(data, kennel[x][y][3]);
        }
     }
     barrier();
     vec4 conv_reslut = vec4(0.0);

     for (int j=0; j < 9; x ++) {
         int start_index = 0;
         int result_index_in_x = start_index;
         int result_index_in_y = start_index + 1;
         int result_index_k_x = start_index + 2;
         int result_index_k_y = start_index + 3;
         if (result_index_k_x >0 && result_index_in_x < 32 && result_index_in_y >0 && result_index_in_y < 32) {
             conv_reslut[0] += result[result_index_in_x][result_index_in_y][result_index_k_x][result_index_in_y][0];
             conv_reslut[1] += result[result_index_in_x][result_index_in_y][result_index_k_x][result_index_in_y][1];
             conv_reslut[2] += result[result_index_in_x][result_index_in_y][result_index_k_x][result_index_in_y][2];
             conv_reslut[3] += result[result_index_in_x][result_index_in_y][result_index_k_x][result_index_in_y][3];
         }
     }

     imageStore(output_image, global_pos.xy,  conv_reslut);
}
