layout (local_size_x = X_SIZE, local_size_y = Y_SIZE, local_size_z = Z_SIZE) in;

uniform int params[14];  // kennel_shape[3] input_shape[3] output_shape[3] strides[2] padding active_type
layout(binding = 0, rgba32f) readonly uniform image2D input_image;
layout(binding = 1, rgba32f) writeonly uniform image2D output_image;
layout(std430, binding = 0) buffer BufferObject {
    ivec2 in_offset[IN_OFFSET_SIZE];
    ivec2 out_offset[OUT_OFFSET_SIZE];
    ivec2 conv_indexes[];
};

ivec2 getRelativeRestoreIndex(int pos, int offset, int[3] output_shape);

void main(void)
{
    // 分解参数
    int kennel_shape[3] = int[3](params[0], params[1] , params[2]);
    int input_shape[3] = int[3](params[3], params[4] , params[5]);
    int output_shape[3] = int[3](params[6], params[7] , params[8]);
    int strides[2] = int[2](params[9], params[10]);
    int padding = params[11];

    int active_type = params[12];
    int align_channel = params[13];
    int count = align_channel / 4;

    int output_area = output_shape[0] * output_shape[1];
    int kennel_area = kennel_shape[0] * kennel_shape[1];


    ivec3 pos = ivec3(gl_GlobalInvocationID.xyz);

    int start_x_index = pos.x * 4;
    int start_z_index = pos.z * 4;

    if (start_x_index >= output_area || start_z_index >= output_shape[2]){
        return;
    }

    int delta = output_area - start_x_index;

    ivec2 out_store_offset = out_offset[pos.z];

    if (delta >= 4) {
        mat4 result;
        int start_conv_index = start_x_index * kennel_area;

        for (int i = 0; i < kennel_area; i++) {
            int conv_index0 = start_conv_index + i;
            int conv_index1 = conv_index0 + kennel_area;
            int conv_index2 = conv_index1 + kennel_area;
            int conv_index3 = conv_index2 + kennel_area;
            ivec2 conv_index_on_tex0 = conv_indexes[conv_index0] + in_offset[0];
            ivec2 conv_index_on_tex1 = conv_indexes[conv_index1] + in_offset[0];
            ivec2 conv_index_on_tex2 = conv_indexes[conv_index2] + in_offset[0];
            ivec2 conv_index_on_tex3 = conv_indexes[conv_index3] + in_offset[0];

            vec4 data0 = imageLoad(input_image, conv_index_on_tex0);
            vec4 data1 = imageLoad(input_image, conv_index_on_tex1);
            vec4 data2 = imageLoad(input_image, conv_index_on_tex2);
            vec4 data3 = imageLoad(input_image, conv_index_on_tex3);

            mat4 data_mat = mat4(data0, data1, data2, data3);

            result = data_mat;
        }

        ivec2 restore_index0 = getRelativeRestoreIndex(start_x_index, 0, output_shape) + out_offset[pos.z];
        ivec2 restore_index1 = getRelativeRestoreIndex(start_x_index, 1, output_shape) + out_offset[pos.z];
        ivec2 restore_index2 = getRelativeRestoreIndex(start_x_index, 2, output_shape) + out_offset[pos.z];
        ivec2 restore_index3 = getRelativeRestoreIndex(start_x_index, 3, output_shape) + out_offset[pos.z];



        imageStore(output_image, restore_index0.xy,  result[0]);
        imageStore(output_image, restore_index1.xy,  result[1]);
        imageStore(output_image, restore_index2.xy,  result[2]);
        imageStore(output_image, restore_index3.xy,  result[3]);
    }else if (delta == 3) {


    } else if (delta == 2) {


    } else {


    }
}

int alignBy4(int channel) {
    int align = 4;
    return (channel + (align - 1)) & ~(align - 1);
}

ivec2 getRelativeRestoreIndex(int pos, int offset, int[3] output_shape) {
    int x = (pos + offset) % output_shape[0];
    int y = (pos + offset) / output_shape[0];
    return ivec2(x, y);
}

